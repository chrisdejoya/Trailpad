<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Trailpad</title>
    
<style>
    @font-face {
        font-family: "Swiss721";
        src: url("fonts/Swiss721BT-Black.ttf") format("truetype"),
             url("fonts/Swiss721BT-Black.woff2") format("woff2"),
             url("fonts/Swiss721BT-Black.woff") format("woff");
        font-weight: bold;
        font-style: normal;
    }

    html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        background: transparent;
        font-family: "Swiss721", Arial, sans-serif;
        text-transform: uppercase;
        user-select: none;
	outline: 2px;
    }

    #app { position: absolute; top: 80px; left: 30px;}

    #stickWrapper {
        width: 230px; height: 230px;
        position: absolute; top: -10px; left: 10px;
        background: transparent;
        background-image: url("images/gate_strive.svg");
        background-size: cover;
        border-radius: 0%;
    }

    #stickCanvas {
        width: 100%; height: 100%;
        display: block;
        background: transparent;
        z-index: 1;
    }

    .joystickHead {
        position: absolute; left: 50%; top: 50%;
        width: 50px; height: 50px;
        border-radius: 50%;
        outline: 4px solid rgba(255,255,255,0.3);
        outline-offset: -4px;
        box-shadow: 0px 0px 0px 5px rgba(0,0,0,1);
        transform: translate(-50%,-50%) scale(1);
        pointer-events: none;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 24px;
        transition: left 0.01s, top 0.01s, transform 0.1s;
        background: rgba(128,128,128,1); color: #000; z-index: 3;
    }

    #directionMarkers {
        position: absolute; top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none; z-index: 2;
    }

    .marker {
        position: absolute; width: 10px; height: 10px;
        border-radius: 50%; background: rgba(255,255,255,0.1);
        transform: translate(-50%, -50%);
        transition: all 0.1s;
    }

    .marker.active { background: rgba(255,255,255,1); }

    .btn {
        position: absolute; background: rgba(0,0,0,1);
        width: 90px; height: 90px;
        display: flex; align-items: center; justify-content: center;
        font-size: 36px; transition: 0.05s;
        border-radius: 50%; outline: 6px solid rgba(255,255,255,0.3);
        outline-offset: -6px; box-shadow: 0 2px 0px 6px rgba(0,0,0,1);
        filter: brightness(0.9);
        overflow: hidden; text-align: center; white-space: nowrap;
        color: #000; cursor: pointer;
    }

    /*
    2XKO Default in-game button colors:
    L:		#B8ADD9
    M:		#9C7ACC
    H:		#6C30BF
    D:		#D98041
    S1:		#4CB6D9
    S2:		#CC5C5C
    T:		#C3E67E
    P:		#3D6DCC
    TH:		#D9B64C
    TA:		#805973
    DS:		#D9B64C
    ULT:	#7F47CC	
    */

    .btn[data-btn="Up"]		{ background: #171717; top: 230px; left: 80px; background-image: url("images/up.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Down"]	{ background: #171717; top: 390px; left: 80px; background-image: url("images/down.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Left"]	{ background: #171717; top: 310px; left: 0px; background-image: url("images/left.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Right"]	{ background: #171717; top: 310px; left: 160px; background-image: url("images/right.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }

    .btn[data-btn="A"] { background: #4CB6D9; top: 110px; left: 250px; }
    .btn[data-btn="B"] { background: #CC5C5C; top: 110px; left: 360px; }
    .btn[data-btn="X"] { background: #B8ADD9; top: 0px; left: 250px; }
    .btn[data-btn="Y"] { background: #9C7ACC; top: 0px; left: 360px; }

    .btn[data-btn="LB"] { background: #D98041; top: 0px; left: 580px; }
    .btn[data-btn="RB"] { background: #6C30BF; top: 0px; left: 470px; }
    .btn[data-btn="LT"] { background: #3D6DCC; top: 110px; left: 580px; }
    .btn[data-btn="RT"] { background: #C3E67E; top: 110px; left: 470px; }

    .btn[data-btn="LS"] { background: #D9B64C; top: 210px; left: 310px; width: 80px; height: 80px; }
    .btn[data-btn="RS"] { background: #805973; top: 210px; left: 530px; width: 80px; height: 80px; }
    .btn[data-btn="View"] { background: #646464; top: -60px; left: 310px; width: 80px; height: 40px; border-radius: 30px; font-size: 20px; }
    .btn[data-btn="Menu"] { background: #646464; top: -60px; left: 530px; width: 80px; height: 40px; border-radius: 30px; font-size: 20px; }

    .btn.active { filter: brightness(1.5); transform: scale(1.05); }
    .btn.selected { box-shadow: 0px 0px 0px 8px rgba(255,255,255,1) }
    .stickHighlight.selected { box-shadow: 0px 0px 0px 8px rgba(255,255,255,1) }

    :root {
    --trail-color: #CEEC73; /* default trail color */
    }
</style>
</head>
<body>
<div id="app">
    <div id="stickWrapper" class="stickHighlight">
        <div id="directionMarkers">
            <div class="marker" id="marker0"></div>
            <div class="marker" id="marker1"></div>
            <div class="marker" id="marker2"></div>
            <div class="marker" id="marker3"></div>
            <div class="marker" id="marker4"></div>
            <div class="marker" id="marker5"></div>
            <div class="marker" id="marker6"></div>
            <div class="marker" id="marker7"></div>
        </div>
        <canvas id="stickCanvas"></canvas>
        <div class="joystickHead" id="joystickHead"></div>
    </div>

    <div class="btn" data-btn="Up"></div>
    <div class="btn" data-btn="Down"></div>
    <div class="btn" data-btn="Left"></div>
    <div class="btn" data-btn="Right"></div>
    <div class="btn" data-btn="A">A</div>
    <div class="btn" data-btn="B">B</div>
    <div class="btn" data-btn="X">X</div>
    <div class="btn" data-btn="Y">Y</div>
    <div class="btn" data-btn="LB">LB</div>
    <div class="btn" data-btn="RB">RB</div>
    <div class="btn" data-btn="LT">LT</div>
    <div class="btn" data-btn="RT">RT</div>
    <div class="btn" data-btn="LS">LS</div>
    <div class="btn" data-btn="RS">RS</div>
    <div class="btn" data-btn="View">View</div>
    <div class="btn" data-btn="Menu">Menu</div>
</div>

<script>
const cfg = {
    deadzone: 0.1,
    trail: 12,
    invertY: false,
    map: {
        A:0,
        B:1,
        X:2,
        Y:3,
        LB:4,
        RB:5,
        LT:6,
        RT:7,
        View:8,
        Menu:9,
        LS:10,
        RS:11,
        Up:12,
        Down:13,
        Left:14,
        Right:15
    },
    ignoredForJoystick: ['View','Menu','LS','RS','Up','Down','Left','Right']
};

const btnEls = {};
document.querySelectorAll('.btn').forEach(el => btnEls[el.dataset.btn] = el);

const savedLabels = JSON.parse(localStorage.getItem("buttonLabels") || "{}");
for (const key in savedLabels) if (btnEls[key]) btnEls[key].textContent = savedLabels[key];

const savedPositions = JSON.parse(localStorage.getItem("buttonPositions") || "{}");
for (const key in savedPositions) if (btnEls[key]) {
    btnEls[key].style.top = savedPositions[key].top;
    btnEls[key].style.left = savedPositions[key].left;
}

const savedSizes = JSON.parse(localStorage.getItem("elementSizes") || "{}");
const stickWrapper = document.getElementById('stickWrapper');
const joystick = document.querySelector('.joystickHead');
const movableElements = {...btnEls, stickWrapper};

const hiddenButtons = JSON.parse(localStorage.getItem("hiddenButtons") || "[]");
hiddenButtons.forEach(btnName => {
    if (btnEls[btnName]) {
        btnEls[btnName].style.display = "none";
        if (!cfg.ignoredForJoystick.includes(btnName)) cfg.ignoredForJoystick.push(btnName);
    }
});

const joystickHidden = localStorage.getItem("joystickHidden") === "true";
if (joystickHidden) {
    stickWrapper.style.display = "none";
}

for (const key in savedSizes) {
    const el = movableElements[key];
    if (el) {
        el.style.width = savedSizes[key].width || el.style.width;
        el.style.height = savedSizes[key].height || el.style.height;
        el.style.borderRadius = savedSizes[key].borderRadius || el.style.borderRadius;
        if (savedSizes[key].fontSize) el.style.fontSize = savedSizes[key].fontSize;
    }
}

const savedStickPos = JSON.parse(localStorage.getItem("stickWrapperPosition") || "{}");
if (savedStickPos.top) stickWrapper.style.top = savedStickPos.top;
if (savedStickPos.left) stickWrapper.style.left = savedStickPos.left;

// Editable labels
Object.values(btnEls).forEach(btn => {
    if (['Up','Down','Left','Right'].includes(btn.dataset.btn)) return;
    btn.addEventListener("click", () => {
        if (btn.querySelector("input")) return;
        const oldText = btn.textContent.trim();
        btn.textContent = "";
        const input = document.createElement("input");
        input.value = oldText;
        input.style.width = "100%";
        input.style.height = "100%";
        input.style.fontSize = btn.style.fontSize || "36px";
        input.style.fontFamily = "inherit";
        input.style.textAlign = "center";
        input.style.textTransform = "uppercase";
        input.style.border = "none";
        input.style.outline = "none";
        input.style.background = "transparent";
        input.style.color = "inherit";
        input.style.padding = "0"; input.style.margin = "0";
        btn.appendChild(input);
        input.focus(); input.select();
        input.addEventListener("blur", save);
        input.addEventListener("keydown", e => {
            if (e.key === "Enter") save();
            else if (e.key === "Escape") btn.textContent = oldText;
        });
        function save() {
            const newText = input.value.trim();
            btn.textContent = newText;
            savedLabels[btn.dataset.btn] = newText;
            localStorage.setItem("buttonLabels", JSON.stringify(savedLabels));
        }
    });
});

// Select & move elements
let selectedElement = null;
Object.values(movableElements).forEach(el => {
    el.addEventListener('mousedown', e => {
        if (selectedElement && selectedElement !== el) selectedElement.classList?.remove("selected");
        selectedElement = el;
        el.classList.add("selected");
        e.stopPropagation();
    });
});
document.addEventListener("mousedown", () => {
    if (selectedElement) selectedElement.classList?.remove("selected");
    selectedElement = null;
});

// Keyboard Controls
document.addEventListener("keydown", e => {
    // ESC: reset everything
    if (e.key === "Escape") {
        localStorage.removeItem("buttonLabels");
        localStorage.removeItem("buttonPositions");
        localStorage.removeItem("stickWrapperPosition");
        localStorage.removeItem("elementSizes");
        localStorage.removeItem("hiddenButtons");
        location.reload();
        return;
    }

    // Unhide all
    if (e.key === "Home") {
        Object.values(btnEls).forEach(btn => btn.style.display = "flex");
        hiddenButtons.length = 0;
        localStorage.setItem("hiddenButtons", JSON.stringify(hiddenButtons));

        // Restore joystick too
        stickWrapper.style.display = "block";
        localStorage.removeItem("joystickHidden");

        // Always keep View and Menu ignored
        cfg.ignoredForJoystick = ['View', 'Menu', ...cfg.ignoredForJoystick.filter(b => b !== 'View' && b !== 'Menu')];
        e.preventDefault();
        return;
    }
    
    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top)||0, left = parseInt(style.left)||0;
    let width = parseInt(style.width)||0, height = parseInt(style.height)||0;
    let borderRadius = parseInt(style.borderRadius)||0;
    let fontSize = parseInt(style.fontSize)||36;
    let updated = false;

    function snap10(val){ return Math.round(val/10)*10; }

    if (e.ctrlKey) {
        if (e.key === "[") { fontSize = Math.max(8, fontSize-2); updated=true; e.preventDefault(); }
        if (e.key === "]") { fontSize += 2; updated=true; e.preventDefault(); }
        selectedElement.style.fontSize = fontSize + "px";
    } else {
        // Move
        if (!e.shiftKey) {
            if (e.key === "ArrowUp") { top -= 10; updated=true; }
            if (e.key === "ArrowDown") { top += 10; updated=true; }
            if (e.key === "ArrowLeft") { left -= 10; updated=true; }
            if (e.key === "ArrowRight") { left += 10; updated=true; }
        }

        // Resize
        if (e.shiftKey) {
            if (selectedElement.id === "stickWrapper") {
                if (e.key === "ArrowUp" || e.key === "ArrowRight") { 
                    width += 10; height += 10; updated = true; 
                }
                if (e.key === "ArrowDown" || e.key === "ArrowLeft") { 
                    width = Math.max(50, width - 10); 
                    height = Math.max(50, height - 10); 
                    updated = true; 
                }
            } else {
                if (e.key === "ArrowDown") { height -= 10; updated=true; }
                if (e.key === "ArrowUp") { height += 10; updated=true; }
                if (e.key === "ArrowLeft") { width -= 10; updated=true; }
                if (e.key === "ArrowRight") { width += 10; updated=true; }
            }
        }

        if (e.key === "[") { borderRadius = Math.max(0,borderRadius-10); updated=true; }
        if (e.key === "]") { borderRadius += 10; updated=true; }
    
	// Hide
	if (e.key === "Delete") {
	    if (selectedElement?.classList.contains("btn")) {
	        // Existing button hide logic
	        selectedElement.style.display = "none";
	        const btnName = selectedElement.dataset.btn;
	        if (!hiddenButtons.includes(btnName)) hiddenButtons.push(btnName);
	        localStorage.setItem("hiddenButtons", JSON.stringify(hiddenButtons));
	        if (!cfg.ignoredForJoystick.includes(btnName)) cfg.ignoredForJoystick.push(btnName);
	        e.preventDefault();
	        return;
	    } else if (selectedElement?.id === "stickWrapper") {
	        // Hide the entire joystick and its parts
	        selectedElement.style.display = "none";
	        localStorage.setItem("joystickHidden", "true");
	        e.preventDefault();
	        return;
	    }
	}
    }

    if (updated) {
        selectedElement.style.top = snap10(top)+"px";
        selectedElement.style.left = snap10(left)+"px";
        selectedElement.style.width = snap10(width)+"px";
        selectedElement.style.height = snap10(height)+"px";
        selectedElement.style.borderRadius = snap10(borderRadius)+"px";
        selectedElement.style.fontSize = fontSize + "px";

        const savedSizesLS = JSON.parse(localStorage.getItem("elementSizes")||"{}");
        if (selectedElement.dataset?.btn) {
            savedPositions[selectedElement.dataset.btn] = {top:selectedElement.style.top, left:selectedElement.style.left};
            localStorage.setItem("buttonPositions", JSON.stringify(savedPositions));
            savedSizesLS[selectedElement.dataset.btn] = {
                width:selectedElement.style.width,
                height:selectedElement.style.height,
                borderRadius:selectedElement.style.borderRadius,
                fontSize:selectedElement.style.fontSize
            };
        } else if (selectedElement.id==="stickWrapper") {
            localStorage.setItem("stickWrapperPosition", JSON.stringify({top:selectedElement.style.top,left:selectedElement.style.left}));
            savedSizesLS["stickWrapper"] = {
                width:selectedElement.style.width,
                height:selectedElement.style.height,
                borderRadius:selectedElement.style.borderRadius
            };

            // recalc canvas + recenter joystick & markers
            resizeCanvas();
            joystick.style.left = (canvas.width / 2) + "px";
            joystick.style.top = (canvas.height / 2) + "px";
            updateMarkers(-1);
        }
        localStorage.setItem("elementSizes", JSON.stringify(savedSizesLS));
    }
});

function moveSelectedElement(dx, dy) {
    if (!selectedElement) return;

    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top) || 0;
    let left = parseInt(style.left) || 0;

    top += dy;
    left += dx;

    // Snap to 10px grid
    function snap10(val) { return Math.round(val / 10) * 10; }
    selectedElement.style.top = snap10(top) + "px";
    selectedElement.style.left = snap10(left) + "px";

    // Save position
    const savedPositionsLS = JSON.parse(localStorage.getItem("buttonPositions") || "{}");
    if (selectedElement.dataset?.btn) {
        savedPositionsLS[selectedElement.dataset.btn] = { top: selectedElement.style.top, left: selectedElement.style.left };
        localStorage.setItem("buttonPositions", JSON.stringify(savedPositionsLS));
    } else if (selectedElement.id === "stickWrapper") {
        localStorage.setItem("stickWrapperPosition", JSON.stringify({ top: selectedElement.style.top, left: selectedElement.style.left }));
    }
}

const elementMoveTimers = { up: 0, down: 0, left: 0, right: 0 };
const moveDelay = 150; // ms between movements
const moveStep = 10;   // 10px increments

function handleDpadMovement(pad) {
    if (!selectedElement || !pad) return;

    const now = performance.now();

    const directions = [
        { btn: 12, dx: 0, dy: -moveStep, key: "up" },   // Up
        { btn: 13, dx: 0, dy: moveStep, key: "down" },  // Down
        { btn: 14, dx: -moveStep, dy: 0, key: "left" }, // Left
        { btn: 15, dx: moveStep, dy: 0, key: "right" }  // Right
    ];

    directions.forEach(dir => {
        if (pad.buttons[dir.btn]?.pressed && now - elementMoveTimers[dir.key] > moveDelay) {
            moveSelectedElement(dir.dx, dir.dy);
            elementMoveTimers[dir.key] = now;
        }
    });
}

// Gamepad logic
let activeGamepadIndex = null;

function detectActiveGamepad() {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
        const pad = gamepads[i];
        if (!pad) continue;
        const anyButtonPressed = pad.buttons.some(b => b.pressed);
        const anyAxisMoved = pad.axes.some(a => Math.abs(a) > cfg.deadzone);
        if (anyButtonPressed || anyAxisMoved) return i;
    }
    return null;
}

window.addEventListener('gamepadconnected', e => console.log("Connected:", e.gamepad.id, e.gamepad.index));
window.addEventListener('gamepaddisconnected', e => {
    console.log("Disconnected:", e.gamepad.id, e.gamepad.index);
    if (activeGamepadIndex === e.gamepad.index) activeGamepadIndex = null;
});

const lastPressedTimes = {};
function updateButtons(pad){
    if(!pad?.buttons){
        joystick.style.transform='translate(-50%,-50%) scale(1)'; joystick.textContent='';
        joystick.style.background='rgba(128,128,128,1)'; joystick.style.color='#fff';
        Object.values(btnEls).forEach(btn=>btn.classList.remove('active'));
        return;
    }
    for(const key in btnEls){
        const idx=cfg.map[key];
        if(idx===undefined) continue;
        const pressed=!!pad.buttons[idx]?.pressed;
        btnEls[key].classList.toggle('active',pressed);
        lastPressedTimes[key]=pressed?performance.now():lastPressedTimes[key]||0;
    }
    let activeBtn=null,latestTime=-1;
    for(const key in lastPressedTimes){
        if(btnEls[key].classList.contains('active')&&!cfg.ignoredForJoystick.includes(key)
           && lastPressedTimes[key]>latestTime){
            latestTime=lastPressedTimes[key]; activeBtn=key;
        }
    }
    if(activeBtn){
        const btnColor=window.getComputedStyle(btnEls[activeBtn]).backgroundColor;
        const btnTextColor=window.getComputedStyle(btnEls[activeBtn]).color;
        joystick.style.transform='translate(-50%,-50%) scale(1.3)';
        joystick.textContent=btnEls[activeBtn].textContent;
        joystick.style.background=btnColor;
        joystick.style.color=btnTextColor;
    } else {
        joystick.style.transform='translate(-50%,-50%) scale(1)';
        joystick.textContent=''; joystick.style.background='rgba(128,128,128,1)';
        joystick.style.color='#fff';
    }
}

// Stick helpers
function radialDeadzone(x,y,dz){ const mag=Math.hypot(x,y); if(mag<dz) return {x:0,y:0}; const s=(mag-dz)/(1-dz); return {x:x*s/mag,y:y*s/mag}; }
function clampCircle(x,y){ const mag=Math.hypot(x,y); if(mag>1) return {x:x/mag,y:y/mag}; return {x,y}; }
function getStickXY(pad){ if(!pad) return {x:0,y:0}; let {x,y}=radialDeadzone(pad.axes[0]||0,pad.axes[1]||0,cfg.deadzone); const up=pad.buttons[12]?.pressed?1:0; const down=pad.buttons[13]?.pressed?1:0; const left=pad.buttons[14]?.pressed?1:0; const right=pad.buttons[15]?.pressed?1:0; if(up||down||left||right){ y=(up?-1:0)+(down?1:0); x=(left?-1:0)+(right?1:0); if(x&&y){x*=0.85;y*=0.85;} } return clampRoundedSquare(x,cfg.invertY?-y:y); }

function clampRoundedSquare(x, y, n = 8) {
    // n = roundness factor: 4=circle, higher=more square
    const mag = Math.pow(Math.abs(x), n) + Math.pow(Math.abs(y), n);
    if (mag > 1) {
        const scale = Math.pow(mag, -1/n);
        return { x: x * scale, y: y * scale };
    }
    return { x, y };
}

function updateMarkers(idx){
    const dirs = [
        {x: 1, y: 0},      // Right
        {x: 0.95, y: 0.95},  // Bottom-right
        {x: 0, y: 1},      // Bottom
        {x: -0.95, y: 0.95}, // Bottom-left
        {x: -1, y: 0},     // Left
        {x: -0.95, y: -0.95},// Top-left
        {x: 0, y: -1},     // Top
        {x: 0.95, y: -0.95}  // Top-right
    ];

    const radiusPct = 38; // distance from center
    const n = 4; // squircle roundness factor; tweak for exact look

    dirs.forEach((d,i)=>{
        const m = document.getElementById('marker'+i);
        const clamped = clampRoundedSquare(d.x, d.y, n);
        m.style.left = (50 + clamped.x * radiusPct) + '%';
        m.style.top  = (50 + clamped.y * radiusPct) + '%';
        m.classList.toggle('active', i === idx);
    });
}

const canvas=document.getElementById('stickCanvas'), ctx=canvas.getContext('2d');
let trail=[];
function resizeCanvas(){ canvas.width=stickWrapper.clientWidth; canvas.height=stickWrapper.clientHeight; }
resizeCanvas(); window.addEventListener('resize',resizeCanvas);

function drawTrail(x,y){
    const cx=canvas.width/2, cy=canvas.height/2, cr=Math.min(canvas.width, canvas.height)/2-10;
    if(typeof x!=='undefined' && typeof y!=='undefined'){ trail.push({x:x,y:y}); if(trail.length>cfg.trail) trail.shift(); }
    if(!trail.length || trail.length<2){ ctx.clearRect(0,0,canvas.width,canvas.height); return; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const trailColor = (getComputedStyle(document.documentElement).getPropertyValue('--trail-color')||'#CEEC73').trim();
    const first = trail[0]; const entriesAreNormalized = Math.abs(first.x)<=1.01 && Math.abs(first.y)<=1.01;
    for(let i=1;i<trail.length;i++){
        const p0=trail[i-1],p1=trail[i],t=i/trail.length;
        const x0=entriesAreNormalized?cx+p0.x*cr:p0.x, y0=entriesAreNormalized?cy+p0.y*cr:p0.y;
        const x1=entriesAreNormalized?cx+p1.x*cr:p1.x, y1=entriesAreNormalized?cy+p1.y*cr:p1.y;
        if(!isFinite(x0)||!isFinite(y0)||!isFinite(x1)||!isFinite(y1)) continue;
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1);
        ctx.lineWidth = 10*(t*2); ctx.lineCap='round'; ctx.globalAlpha=1; ctx.strokeStyle=trailColor; ctx.stroke();
    }
    ctx.globalAlpha=1;
}

// Animate loop
function animate(){
    activeGamepadIndex = detectActiveGamepad();
    const pad = navigator.getGamepads()[activeGamepadIndex];
    updateButtons(pad);
    handleDpadMovement(pad);
    const {x,y}=getStickXY(pad);
    const cx=canvas.width/2, cy=canvas.height/2;
    const radius=canvas.width/2 - 25;
    const jx=cx+x*radius, jy=cy+y*radius;
    joystick.style.left=jx+'px';
    joystick.style.top=jy+'px';
    const deg=(Math.atan2(y,x)*180/Math.PI+360)%360;
    let idx=-1;
    if(Math.hypot(x,y)>0.5) idx=Math.round(deg/45)%8;
    updateMarkers(idx);
    trail.push({x:jx,y:jy}); if(trail.length>cfg.trail) trail.shift();
    drawTrail();
    requestAnimationFrame(animate);
}
animate();
</script>

</body>
</html>
