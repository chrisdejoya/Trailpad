<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Trailpad</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
    
<style>
    @font-face {
        font-family: "Swiss721";
        src: url("fonts/Swiss721BT-Black.ttf") format("truetype"),
             url("fonts/Swiss721BT-Black.woff2") format("woff2"),
             url("fonts/Swiss721BT-Black.woff") format("woff");
        font-weight: bold;
        font-style: normal;
    }

    html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        background: transparent;
        font-family: "Swiss721", Arial, sans-serif;
        text-transform: uppercase;
        user-select: none;
    }

    #app { position: absolute; top: 0px; left: 0px; }
	
	#base {
		position: absolute; width: 690px; height: 250px; left: 30px; top: 40px;
		background: rgba(0,0,0,0.6); outline: 6px solid rgba(0,0,0,0.3); outline-offset: -6px;
		z-index: 0; display: block;
	}
	
	#base.selected {
		box-shadow: 0 0 0 4px rgba(255,255,255,0.8) inset;
	}

    #stickWrapper {
        width: 230px; height: 230px;
        position: absolute; top: 50px; left: 50px;
        background: transparent;
        background-image: url("images/gate_strive.svg");
        background-size: cover;
        border-radius: 0%;
    }

    #stickCanvas {
        width: 100%; height: 100%;        
        background: transparent;
		display: block;
    }

    .joystickHead {
        position: absolute; left: 50%; top: 50%;
        width: 60px; height: 60px;
        border-radius: 50%;
        outline: 4px solid rgba(255,255,255,0.5);
        outline-offset: -4px;
        box-shadow: 0px 2px 0px 5px rgba(0,0,0,1);
        transform: translate(-50%,-50%) scale(1);
        pointer-events: none;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 28px;
        //transition: left 0.05s, top 0.05s, transform: 0.1;
        background: rgba(80,80,80,1); color: #000;
    }

    #directionMarkers {
        position: absolute; top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none;
    }

    .marker {
        position: absolute; width: 8px; height: 8px;
        border-radius: 50%; background: rgba(255,255,255,0.1);
        transform: translate(-50%, -50%);
        transition: all 0.1s;
    }

    .marker.active { background: rgba(255,255,255,1); }

    .btn {
        position: absolute; background: rgba(48,48,48,1);
        width: 90px; height: 90px;
        display: flex; align-items: center; justify-content: center;
        font-size: 44px; transition: 0.05s;
        border-radius: 50%;		
		outline: 4px solid rgba(255,255,255,0.3); outline-offset: -4px; 
        box-shadow: 0 2px 0px 6px rgba(0,0,0,1);
        filter: brightness(1);
        overflow: hidden; text-align: center; white-space: nowrap;
        color: #eee; cursor: pointer;
		z-index: 1;
    }	
    .btn.active { filter: brightness(2.0); transform: scale(1.15); z-index: 2; }
    .btn.selected { box-shadow: 0px 2px 0px 6px rgba(255,255,255,1) }

    .btn[data-btn="Up"]		{ top: 390px; left: 120px; background-image: url("images/up.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Down"]	{ top: 290px; left: 120px; background-image: url("images/down.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Left"]	{ top: 290px; left: 20px; background-image: url("images/left.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Right"]	{ top: 290px; left: 220px; background-image: url("images/right.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }

    .btn[data-btn="A"] { top: 170px; left: 300px; }
    .btn[data-btn="B"] { top: 170px; left: 400px; }
    .btn[data-btn="X"] { top: 70px; left: 300px; }
    .btn[data-btn="Y"] { top: 70px; left: 400px; }

    .btn[data-btn="LB"] { top: 70px; left: 600px; }
    .btn[data-btn="RB"] { top: 70px; left: 500px; }
    .btn[data-btn="LT"] { top: 170px; left: 600px; }
    .btn[data-btn="RT"] { top: 170px; left: 500px; }

    .btn[data-btn="LS"] { top: 280px; left: 360px; width: 70px; height: 70px; font-size: 36px }
    .btn[data-btn="RS"] { top: 280px; left: 560px; width: 70px; height: 70px; font-size: 36px  }
    .btn[data-btn="View"] { top: 20px; left: 300px; width: 90px; height: 40px; border-radius: 30px; font-size: 20px; }
    .btn[data-btn="Menu"] { top: 20px; left: 400px; width: 90px; height: 40px; border-radius: 30px; font-size: 20px; }

    .stickHighlight.selected { box-shadow: 0px 0px 0px 8px rgba(255,255,255,1) }

    :root {
    --trail-color: #CEEC73; /* default trail color */	
    }	

    /* Palette + toast minimal styles */
    #colorPanel { position: fixed; bottom: 0; left: 0; width: 100%; display: block; background: #000; padding: 10px; z-index: 1000; flex-wrap: wrap; gap: 4px; }
    #colorPanel .swatch { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; }
	#colorPanel .swatch:hover { outline: 4px solid #fff; outline-offset: -2px; }
    #colorPanel .modeToggle { width: 100%; display: flex; justify-content: center; gap:0; margin-bottom:0; }
    //#toast { position: absolute; top: 25%; left: 50%; transform: translate(-50%, -25%) scale(0); background: #222222ee; box-shadow: 0px 2px 0px 8px #000; color:#fff; text-align: center; width: 400px; padding: 15px; z-index:100; transition: transform 0.1s ease; font-family: Swiss721, Arial, sans-serif; font-size: 30px; outline: 4px solid #eeeeee88; }

	#toast {
		position: absolute; z-index: 100;
		top: 25%; left: 50%;		
		transform: translate(-50%, -25%) scale(0);
		width: 90%; padding: 20px; padding-left: 50px; padding-right: 50px;
		font-family: Swiss721, Arial, sans-serif; font-size: 30px;		
		color:#fff; text-align: center;
		transition: transform 0.1s ease;
		text-shadow: 0 2px 2px rgba(0,0,0,2.0);		
		background: rgba(0,0,0,0.8);
		
		/* fade edges */
		-webkit-mask-image: linear-gradient(to right,
						  rgba(0,0,0,0) 0%,
						  rgba(0,0,0,1) 15%,
						  rgba(0,0,0,1) 85%,
						  rgba(0,0,0,0) 100%);
		-webkit-mask-repeat: no-repeat;
		-webkit-mask-size: 100% 100%;
		mask-image: linear-gradient(to right,
						  rgba(0,0,0,0) 0%,
						  rgba(0,0,0,1) 15%,
						  rgba(0,0,0,1) 85%,
						  rgba(0,0,0,0) 100%);
		mask-repeat: no-repeat;
		mask-size: 100% 100%;	  
		}
</style>
</head>
<body>
<div id="base"></div>
<div id="app">
    <div id="stickWrapper" class="stickHighlight">
        <div id="directionMarkers">
            <div class="marker" id="marker0"></div>
            <div class="marker" id="marker1"></div>
            <div class="marker" id="marker2"></div>
            <div class="marker" id="marker3"></div>
            <div class="marker" id="marker4"></div>
            <div class="marker" id="marker5"></div>
            <div class="marker" id="marker6"></div>
            <div class="marker" id="marker7"></div>
        </div>
        <canvas id="stickCanvas"></canvas>
        <div class="joystickHead" id="joystickHead"></div>
    </div>
	
    <div class="btn" data-btn="Up"></div>
    <div class="btn" data-btn="Down"></div>
    <div class="btn" data-btn="Left"></div>
    <div class="btn" data-btn="Right"></div>
    <div class="btn" data-btn="A">A</div>
    <div class="btn" data-btn="B">B</div>
    <div class="btn" data-btn="X">X</div>
    <div class="btn" data-btn="Y">Y</div>
    <div class="btn" data-btn="LB">LB</div>
    <div class="btn" data-btn="RB">RB</div>
    <div class="btn" data-btn="LT">LT</div>
    <div class="btn" data-btn="RT">RT</div>
    <div class="btn" data-btn="LS">LS</div>
    <div class="btn" data-btn="RS">RS</div>
    <div class="btn" data-btn="View">View</div>
    <div class="btn" data-btn="Menu">Menu</div>
</div>

<!-- color panel -->
<div id="colorPanel" aria-hidden="true"></div>
<!-- toast -->
<div id="toast" aria-hidden="true"></div>

<script>
/* ===========================
   Unified appState and helpers
   =========================== */

const STORAGE_KEY = "trailpad_appState";
const defaultTrailColor = getComputedStyle(document.documentElement).getPropertyValue('--trail-color').trim() || "#CEEC73";

const defaultCfg = {
    deadzone: 0.1,
    trail: 12,
    invertY: false,
    map: {
        A:0, B:1, X:2, Y:3, LB:4, RB:5, LT:6, RT:7,
        View:8, Menu:9, LS:10, RS:11, Up:12, Down:13, Left:14, Right:15
    },
    ignoredForJoystick: ['View','Menu','LS','RS','Up','Down','Left','Right']
};

let cfg = {...defaultCfg};

// elements
const btnEls = {};
document.querySelectorAll('.btn').forEach(el => btnEls[el.dataset.btn] = el);
const stickWrapper = document.getElementById('stickWrapper');
const joystick = document.getElementById('joystickHead');
const canvas = document.getElementById('stickCanvas');
const ctx = canvas.getContext('2d');

const movableElements = {...btnEls, stickWrapper, base};

/* appState schema:
{
  buttons: {
    A: { top, left, width, height, borderRadius, fontSize, display, backgroundColor, color, label },
    ...
  },
  joystick: { top, left, width, height, borderRadius, display },
  hiddenButtons: [ ... ],
  trailColor: "#xxxxxx",
  profiles: { profile1: {...}, ... }
}
*/

let appState = {
    buttons: {},      				// per-button properties
    joystick: {},     				// stickWrapper properties
    hiddenButtons: [],				// array of names hidden
    trailColor: defaultTrailColor,
    profiles: {} 				     // profile1..profile4
};

/* Debounced save to reduce churn */
let saveTimer = null;
function scheduleSave() {
    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
        } catch (e) {
            console.warn("Failed to save state:", e);
        }
    }, 120); // 120ms debounce
}

function forceSave() {
    clearTimeout(saveTimer);
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
    } catch (e) {
        console.warn("Failed to save state:", e);
    }
}

/* Load state once */
function loadState() {
	try {
		const raw = localStorage.getItem(STORAGE_KEY);
		if (raw) {
			appState = { ...appState, ...JSON.parse(raw) };
		}
	} catch (err) {
		console.warn("Failed to load saved state:", err);
		appState = { ...defaultState }; // fallback
	}
    applyState();
}

/* Apply stored data to DOM elements */
function applyElementData(el, data) {
    if (!el || !data) return;
    if (data.top) el.style.top = data.top;
    if (data.left) el.style.left = data.left;
    if (data.width) el.style.width = data.width;
    if (data.height) el.style.height = data.height;
    if (data.borderRadius) el.style.borderRadius = data.borderRadius;
    if (data.fontSize) el.style.fontSize = data.fontSize;
    if (data.display) el.style.display = data.display;
    if (data.backgroundColor) el.style.backgroundColor = data.backgroundColor;
    if (data.color) el.style.color = data.color;
    if (data.label !== undefined && el.dataset?.btn) el.textContent = data.label;
}

function applyState() {
    // buttons
    for (const key in btnEls) {
        const el = btnEls[key];
        const data = appState.buttons[key] || {};
        // apply defaults if not set
        // Use computed style fallback if not present in state
        const computed = window.getComputedStyle(el);
        const fallback = {
            top: el.style.top || computed.top || computed.getPropertyValue('top'),
            left: el.style.left || computed.left || computed.getPropertyValue('left'),
            width: el.style.width || computed.width,
            height: el.style.height || computed.height,
            borderRadius: el.style.borderRadius || computed.borderRadius,
            fontSize: el.style.fontSize || computed.fontSize,
            display: el.style.display || computed.display,
            backgroundColor: el.style.backgroundColor || computed.backgroundColor,
            color: el.style.color || computed.color,
            label: (el.textContent || "").trim()
        };
        const merged = Object.assign({}, fallback, data);
        applyElementData(el, merged);
        // also write merged values back to state (so state contains every button after apply)
        appState.buttons[key] = {...merged};
    }
	
    // joystick/wrapper
    const sw = appState.joystick || {};
    const computedSW = window.getComputedStyle(stickWrapper);
    const swFallback = {
        top: stickWrapper.style.top || computedSW.top,
        left: stickWrapper.style.left || computedSW.left,
        width: stickWrapper.style.width || computedSW.width,
        height: stickWrapper.style.height || computedSW.height,
        borderRadius: stickWrapper.style.borderRadius || computedSW.borderRadius,
        display: stickWrapper.style.display || computedSW.display
    };
    appState.joystick = Object.assign({}, swFallback, sw);
    applyElementData(stickWrapper, appState.joystick);
	
	// base
	const baseData = appState.base || {};
	const computedBase = window.getComputedStyle(base);
	const baseFallback = {
		top: base.style.top || computedBase.top,
		left: base.style.left || computedBase.left,
		width: base.style.width || computedBase.width,
		height: base.style.height || computedBase.height,
		borderRadius: base.style.borderRadius || computedBase.borderRadius,
		display: base.style.display || computedBase.display,
		backgroundColor: base.style.backgroundColor || computedBase.backgroundColor
	};
	appState.base = Object.assign({}, baseFallback, baseData);
	applyElementData(base, appState.base);

    // hidden buttons
    if (Array.isArray(appState.hiddenButtons)) {
        appState.hiddenButtons.forEach(btnName => {
            if (btnEls[btnName]) {
                btnEls[btnName].style.display = "none";
                if (!cfg.ignoredForJoystick.includes(btnName)) cfg.ignoredForJoystick.push(btnName);
            }
        });
    } else {
        appState.hiddenButtons = [];
    }

    // trail color
    if (appState.trailColor) {
        document.documentElement.style.setProperty('--trail-color', appState.trailColor);
    }

    resizeCanvas();
    joystick.style.left = (canvas.width / 2) + "px";
    joystick.style.top = (canvas.height / 2) + "px";
    updateMarkers(-1);
    scheduleSave();
}

/* Convenience getters for element state */
function getElementState(key) {
    if (!key) return null;
    if (key === "stickWrapper") return appState.joystick || {};
    if (appState.buttons[key]) return appState.buttons[key];
    return null;
}

/* Update single properties and schedule save */
function updatePosition(key, top, left) {
    if (key === "stickWrapper") {
        appState.joystick.top = top;
        appState.joystick.left = left;		
    }
    else if (key === "base") {
        appState.base.top = top;
        appState.base.left = left;
	} else {
        if (!appState.buttons[key]) appState.buttons[key] = {};
        appState.buttons[key].top = top;
        appState.buttons[key].left = left;
    }
    scheduleSave();
}

function updateSize(key, width, height, borderRadius, fontSize) {
    if (key === "stickWrapper") {
        appState.joystick.width = width;
        appState.joystick.height = height;
        if (borderRadius !== undefined) appState.joystick.borderRadius = borderRadius;
    } else if (key === "base") {
        if (width !== undefined) appState.base.width = width;
        if (height !== undefined) appState.base.height = height;
        if (borderRadius !== undefined) appState.base.borderRadius = borderRadius;
	} else {
        if (!appState.buttons[key]) appState.buttons[key] = {};
        if (width !== undefined) appState.buttons[key].width = width;
        if (height !== undefined) appState.buttons[key].height = height;
        if (borderRadius !== undefined) appState.buttons[key].borderRadius = borderRadius;
        if (fontSize !== undefined) appState.buttons[key].fontSize = fontSize;
    }
    scheduleSave();
}

function updateLabel(key, label) {
    if (!appState.buttons[key]) appState.buttons[key] = {};
    appState.buttons[key].label = label;
    scheduleSave();
}

function updateColor(key, background, text) {
    if (key === "trail") {
        appState.trailColor = background;
        document.documentElement.style.setProperty('--trail-color', background);
    } else {
        if (!appState.buttons[key]) appState.buttons[key] = {};
        if (background !== undefined) appState.buttons[key].backgroundColor = background;
        if (text !== undefined) appState.buttons[key].color = text;
    }
    scheduleSave();
}

function setHiddenButton(key, hidden) {
    if (hidden) {
        if (!appState.hiddenButtons.includes(key)) appState.hiddenButtons.push(key);
    } else {
        appState.hiddenButtons = appState.hiddenButtons.filter(k => k !== key);
    }
    // apply immediately
    if (btnEls[key]) btnEls[key].style.display = hidden ? "none" : "block";
    // maintain joystick ignored list
    if (hidden) {
        if (!cfg.ignoredForJoystick.includes(key)) cfg.ignoredForJoystick.push(key);
    } else {
        cfg.ignoredForJoystick = cfg.ignoredForJoystick.filter(b => b !== key || b === 'View' || b === 'Menu');
    }
    scheduleSave();
}

function setJoystickHidden(hidden) {
    appState.joystick.display = hidden ? "none" : "";
    stickWrapper.style.display = hidden ? "none" : "block";
    scheduleSave();
}

function setBaseHidden(hidden) {
    appState.base.display = hidden ? "none" : "";
    base.style.display = hidden ? "none" : "block";
    scheduleSave();
}

/* Profiles */
const PROFILE_COUNT = 4;
function saveProfile(n) {
    if (n < 1 || n > PROFILE_COUNT) return;
    // collect current live state snapshot
    const snapshot = {
        joystick: Object.assign({}, appState.joystick),
        buttons: {},
        base: {
            top: base.style.top || window.getComputedStyle(base).top,
            left: base.style.left || window.getComputedStyle(base).left,
            width: base.style.width || window.getComputedStyle(base).width,
            height: base.style.height || window.getComputedStyle(base).height,
            borderRadius: base.style.borderRadius || window.getComputedStyle(base).borderRadius,
            display: base.style.display || window.getComputedStyle(base).display,
            backgroundColor: base.style.backgroundColor || window.getComputedStyle(base).backgroundColor
        }
    };
    for (const key in btnEls) {
        const el = btnEls[key];
        snapshot.buttons[key] = {
            top: el.style.top || window.getComputedStyle(el).top,
            left: el.style.left || window.getComputedStyle(el).left,
            width: el.style.width || window.getComputedStyle(el).width,
            height: el.style.height || window.getComputedStyle(el).height,
            borderRadius: el.style.borderRadius || window.getComputedStyle(el).borderRadius,
            fontSize: el.style.fontSize || window.getComputedStyle(el).fontSize,
            display: el.style.display || window.getComputedStyle(el).display,
            backgroundColor: el.style.backgroundColor || window.getComputedStyle(el).backgroundColor,
            color: el.style.color || window.getComputedStyle(el).color,
            label: el.textContent || ""
        };
    }
    appState.profiles["profile" + n] = snapshot;
    //scheduleSave();
	forceSave();
    showToast(`Profile ${n} saved!`);
}

function loadProfile(n) {
    if (n < 1 || n > PROFILE_COUNT) return;
    const snap = appState.profiles["profile" + n];
    if (!snap) {
        showToast(`Press ctrl-F${n} to save`);
        return;
    }
    // apply joystick
    if (snap.joystick) {
        appState.joystick = Object.assign({}, snap.joystick);
        applyElementData(stickWrapper, appState.joystick);
    }
    // apply buttons
    for (const key in snap.buttons) {
        const data = snap.buttons[key];
        if (btnEls[key]) {
            applyElementData(btnEls[key], data);
            // mirror into appState.buttons
            appState.buttons[key] = Object.assign({}, data);
        }
    }
	// base
	if (snap.base) {
        Object.assign(appState.base, snap.base);
        applyElementData(base, appState.base);
    }
    // update derived UI
    resizeCanvas();
    joystick.style.left = (canvas.width / 2) + "px";
    joystick.style.top = (canvas.height / 2) + "px";
    updateMarkers(-1);
    //scheduleSave();
	forceSave();
    showToast(`Profile ${n} loaded!`);
}

/* ======================
   Utility & UI helpers
   ====================== */

const toast = document.getElementById('toast');
function bounceToast() {
    toast.style.transition = "transform 0.05s ease";
    toast.style.transform = "translate(-50%, -25%) scale(1.1)";
    setTimeout(() => {
        toast.style.transform = "translate(-50%, -25%) scale(1)";
        toast.style.transition = "transform 0.1s ease";
    }, 80);
}

function showToast(message, duration = 1000) {
    toast.textContent = message;
    if (toast.style.transform.includes("scale(0)")) {
        toast.style.transform = "translate(-50%, -25%) scale(1)";
    } else {
        bounceToast();
    }
    clearTimeout(toast.hideTimeout);
    toast.hideTimeout = setTimeout(() => {
        toast.style.transform = "translate(-50%, -25%) scale(100%, 0%)";
    }, duration);
}

/* ======================
   Editable labels
   ====================== */
Object.values(btnEls).forEach(btn => {
    if (['Up','Down','Left','Right'].includes(btn.dataset.btn)) return;

    btn.addEventListener("dblclick", () => {
        if (btn.querySelector("input")) return;

        const oldText = btn.textContent.trim();
        btn.textContent = "";

        const input = document.createElement("input");
        input.value = oldText;

        // Match button styles exactly
        const style = window.getComputedStyle(btn);
        input.style.position = "absolute";
        input.style.top = "0";
        input.style.left = "0";
        input.style.width = "100%";
        input.style.height = "100%";
        input.style.fontSize = style.fontSize;
        input.style.fontFamily = style.fontFamily;
        input.style.fontWeight = style.fontWeight;
        input.style.textAlign = style.textAlign;
		input.style.textTransform = "uppercase";
        input.style.lineHeight = style.lineHeight;
        input.style.background = "transparent";		
        input.style.border = "none";
        input.style.outline = "none";
        input.style.color = style.color;
        input.style.padding = "0";
        input.style.margin = "0";
        input.style.boxSizing = "border-box";

        btn.appendChild(input);
        input.focus();
        input.select();

        function save() {
            const newText = input.value.trim();
            btn.textContent = newText;
            savedLabels[btn.dataset.btn] = newText;
            localStorage.setItem("buttonLabels", JSON.stringify(savedLabels));
        }

        input.addEventListener("blur", save);
        input.addEventListener("keydown", e => {
            if (e.key === "Enter") save();
            else if (e.key === "Escape") btn.textContent = oldText;
        });
    });
});

/* ======================
   Select & move elements
   ====================== */

let selectedElement = null;
Object.values(movableElements).forEach(el => {
    el.addEventListener('mousedown', e => {
        if (selectedElement && selectedElement !== el) selectedElement.classList?.remove("selected");
        selectedElement = el;
        el.classList.add("selected");
        e.stopPropagation();
    });
});
document.addEventListener("mousedown", () => {
    if (selectedElement) selectedElement.classList?.remove("selected");
    selectedElement = null;
});

/* Keyboard Controls (move/resize/fontsize/border radius/hide/reset/unhide) */
document.addEventListener("keydown", e => {
    // Unhide all
	if (e.key === "Home") {
		// Unhide all buttons
		document.querySelectorAll(".btn").forEach(btn => {
			btn.style.display = "flex";
			const btnKey = btn.getAttribute("data-btn");
			if (appState.buttons[btnKey]) {
				appState.buttons[btnKey].display = "flex";
			}
		});

		// Unhide joystick
		stickWrapper.style.display = "block";
		appState.joystick.display = "block";
		resetJoystick()

		// Unhide base
		base.style.display = "block";
		appState.base.display = "block";

		// Clear hiddenButtons list
		appState.hiddenButtons = [];

		forceSave();
		showToast("Show All Widgets");
	}

    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top)||0, left = parseInt(style.left)||0;
    let width = parseInt(style.width)||0, height = parseInt(style.height)||0;
    let borderRadius = parseInt(style.borderRadius)||0;
    let fontSize = parseInt(style.fontSize)||36;
    let updated = false;

    function snap10(val){ return Math.round(val/10)*10; }
	
	// Edit font size
    if (e.ctrlKey) {
        if (e.key === "[") { fontSize = Math.max(8, fontSize-2); updated=true; e.preventDefault(); }
        if (e.key === "]") { fontSize += 2; updated=true; e.preventDefault(); }
        if (updated) {
            selectedElement.style.fontSize = fontSize + "px";
            // save
            if (selectedElement.dataset?.btn) updateSize(selectedElement.dataset.btn, undefined, undefined, undefined, selectedElement.style.fontSize);
            else if (selectedElement.id === "stickWrapper") updateSize("stickWrapper", undefined, undefined, undefined, selectedElement.style.fontSize);
        }
    } else {
        // Move
        if (!e.shiftKey) {
            if (e.key === "ArrowUp") { top -= 10; updated=true; }
            if (e.key === "ArrowDown") { top += 10; updated=true; }
            if (e.key === "ArrowLeft") { left -= 10; updated=true; }
            if (e.key === "ArrowRight") { left += 10; updated=true; }
        }

        // Resize
        if (e.shiftKey) {
            if (selectedElement.id === "stickWrapper") {
                if (e.key === "ArrowUp" || e.key === "ArrowRight") { 
                    width += 10; height += 10; updated = true; 
                }
                if (e.key === "ArrowDown" || e.key === "ArrowLeft") { 
                    width = Math.max(50, width - 10); 
                    height = Math.max(50, height - 10); 
                    updated = true; 
                }
            } else {
                if (e.key === "ArrowDown") { height = Math.max(10, height - 10); updated=true; }
                if (e.key === "ArrowUp") { height += 10; updated=true; }
                if (e.key === "ArrowLeft") { width = Math.max(10, width - 10); updated=true; }
                if (e.key === "ArrowRight") { width += 10; updated=true; }
            }
        }
		
		// Corner roundness
        if (e.key === "[") { borderRadius = Math.max(0,borderRadius-10); updated=true; }
        if (e.key === "]") { borderRadius += 10; updated=true; }
    
        // Hide
        if (e.key === "Delete") {
		    if (selectedElement?.id === "base") {
				selectedElement.style.display = "none";
				setBaseHidden(true);
				e.preventDefault();
				return;
			} else if (selectedElement?.classList.contains("btn")) {
                selectedElement.style.display = "none";
                const btnName = selectedElement.dataset.btn;
                setHiddenButton(btnName, true);
                e.preventDefault();
                return;
            } else if (selectedElement?.id === "stickWrapper") {
                selectedElement.style.display = "none";
                setJoystickHidden(true);
                e.preventDefault();
                return;
            }
        }
    }

    if (updated) {
        // Apply snapped values
        selectedElement.style.top = snap10(top)+"px";
        selectedElement.style.left = snap10(left)+"px";
        selectedElement.style.width = snap10(width)+"px";
        selectedElement.style.height = snap10(height)+"px";
        selectedElement.style.borderRadius = snap10(borderRadius)+"px";
        
        // Save sizes and positions
        if (selectedElement.dataset?.btn) {
            updatePosition(selectedElement.dataset.btn, selectedElement.style.top, selectedElement.style.left);
            updateSize(selectedElement.dataset.btn, selectedElement.style.width, selectedElement.style.height, selectedElement.style.borderRadius, selectedElement.style.fontSize);
        } else if (selectedElement.id==="stickWrapper") {
            updatePosition("stickWrapper", selectedElement.style.top, selectedElement.style.left);
            updateSize("stickWrapper", selectedElement.style.width, selectedElement.style.height, selectedElement.style.borderRadius, selectedElement.style.fontSize);
            // recalc canvas + recenter joystick & markers
            resizeCanvas();
            joystick.style.left = (canvas.width / 2) + "px";
            joystick.style.top = (canvas.height / 2) + "px";
            updateMarkers(-1);
        }
    }
});

/* Move selected element with helpers (used by gamepad) */
function moveSelectedElement(dx, dy) {
    if (!selectedElement) return;
    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top) || 0;
    let left = parseInt(style.left) || 0;
	
	top = Math.max(0, top);
    left = Math.max(0, left);
	
    top += dy; left += dx;
    function snap10(val) { return Math.round(val / 10) * 10; }
    selectedElement.style.top = snap10(top) + "px";
    selectedElement.style.left = snap10(left) + "px";
    if (selectedElement.dataset?.btn) updatePosition(selectedElement.dataset.btn, selectedElement.style.top, selectedElement.style.left);
    else if (selectedElement.id === "stickWrapper") updatePosition("stickWrapper", selectedElement.style.top, selectedElement.style.left);
}

/* D-pad / hold movement via gamepad */
const elementMoveTimers = { up: 0, down: 0, left: 0, right: 0 };
const moveDelay = 100; // ms
const moveStep = 10;

function handleDpadMovement(pad) {
    if (!selectedElement || !pad) return;
    const now = performance.now();
    const directions = [
        { btn: 12, dx: 0, dy: -moveStep, key: "up" },   // Up
        { btn: 13, dx: 0, dy: moveStep, key: "down" },  // Down
        { btn: 14, dx: -moveStep, dy: 0, key: "left" }, // Left
        { btn: 15, dx: moveStep, dy: 0, key: "right" }  // Right
    ];
    directions.forEach(dir => {
        if (pad.buttons[dir.btn]?.pressed && now - elementMoveTimers[dir.key] > moveDelay) {
            moveSelectedElement(dir.dx, dir.dy);
            elementMoveTimers[dir.key] = now;
        }
    });
}

/* ======================
   Gamepad & Button Updates
   ====================== */

let activeGamepadIndex = null;
function detectActiveGamepad() {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
        const pad = gamepads[i];
        if (!pad) continue;
        const anyButtonPressed = pad.buttons.some(b => b.pressed);
        const anyAxisMoved = pad.axes.some(a => Math.abs(a) > cfg.deadzone);
        if (anyButtonPressed || anyAxisMoved) return i;
    }
    return null;
}

window.addEventListener('gamepadconnected', e => console.log("Connected:", e.gamepad.id, e.gamepad.index));
window.addEventListener('gamepaddisconnected', e => {
    console.log("Disconnected:", e.gamepad.id, e.gamepad.index);
    if (activeGamepadIndex === e.gamepad.index) activeGamepadIndex = null;
});

const lastPressedTimes = {};

function updateButtons(pad) {
    if (!pad?.buttons) {
        // Reset joystick when no gamepad
        joystick.style.transform = 'translate(-50%,-50%) scale(1)';
        joystick.textContent = '';
        joystick.style.background = 'rgba(64,64,64,1)';
        joystick.style.color = '#fff';
        Object.values(btnEls).forEach(btn => btn.classList.remove('active'));
        return;
    }

    // Update button states
    for (const key in btnEls) {
        const idx = cfg.map[key];
        if (idx === undefined) continue;
        const pressed = !!pad.buttons[idx]?.pressed;
        btnEls[key].classList.toggle('active', pressed);
        lastPressedTimes[key] = pressed ? performance.now() : lastPressedTimes[key] || 0;
    }

    // Determine latest active button for joystick display
    let activeBtn = null;
    let latestTime = -1;
    for (const key in lastPressedTimes) {
        if (
            btnEls[key].classList.contains('active') &&
            !cfg.ignoredForJoystick.includes(key) &&
            lastPressedTimes[key] > latestTime
        ) {
            latestTime = lastPressedTimes[key];
            activeBtn = key;
        }
    }

    // Update joystick appearance
    if (activeBtn) {
        const btnColor = window.getComputedStyle(btnEls[activeBtn]).backgroundColor;
        const btnTextColor = window.getComputedStyle(btnEls[activeBtn]).color;
        joystick.style.transform = 'translate(-50%,-50%) scale(1.3)';
        joystick.textContent = btnEls[activeBtn].textContent;
        joystick.style.background = btnColor;
        joystick.style.color = btnTextColor;
    } else {
        // Reset when no button is active
        joystick.style.transform = 'translate(-50%,-50%) scale(1)';
        joystick.textContent = '';
        joystick.style.background = 'rgba(64,64,64,1)';
        joystick.style.color = '#fff';
    }
}

/* ======================
   Stick helpers & trail
   ====================== */

function radialDeadzone(x,y,dz){ const mag=Math.hypot(x,y); if(mag<dz) return {x:0,y:0}; const s=(mag-dz)/(1-dz); return {x:x*s/mag,y:y*s/mag}; }
function clampCircle(x,y){ const mag=Math.hypot(x,y); if(mag>1) return {x:x/mag,y:y/mag}; return {x,y}; }
function clampRoundedSquare(x, y, n = 8) {
    const mag = Math.pow(Math.abs(x), n) + Math.pow(Math.abs(y), n);
    if (mag > 1) {
        const scale = Math.pow(mag, -1/n);
        return { x: x * scale, y: y * scale };
    }
    return { x, y };
}

function getStickXY(pad){ if(!pad) return {x:0,y:0}; let {x,y}=radialDeadzone(pad.axes[0]||0,pad.axes[1]||0,cfg.deadzone); const up=pad.buttons[12]?.pressed?1:0; const down=pad.buttons[13]?.pressed?1:0; const left=pad.buttons[14]?.pressed?1:0; const right=pad.buttons[15]?.pressed?1:0; if(up||down||left||right){ y=(up?-1:0)+(down?1:0); x=(left?-1:0)+(right?1:0); if(x&&y){x*=0.85;y*=0.85;} } return clampRoundedSquare(x,cfg.invertY?-y:y); }

function updateMarkers(idx){
    const dirs = [
        {x: 1, y: 0},
        {x: 0.95, y: 0.95},
        {x: 0, y: 1},
        {x: -0.95, y: 0.95},
        {x: -1, y: 0},
        {x: -0.95, y: -0.95},
        {x: 0, y: -1},
        {x: 0.95, y: -0.95}
    ];

    const radiusPct = 38;
    const n = 4;

    dirs.forEach((d,i)=>{
        const m = document.getElementById('marker'+i);
        const clamped = clampRoundedSquare(d.x, d.y, n);
        m.style.left = (50 + clamped.x * radiusPct) + '%';
        m.style.top  = (50 + clamped.y * radiusPct) + '%';
        m.classList.toggle('active', i === idx);
    });
}

/* Trail drawing */
let trail = [];
function resizeCanvas(){ canvas.width = stickWrapper.clientWidth; canvas.height = stickWrapper.clientHeight; }
resizeCanvas(); window.addEventListener('resize', resizeCanvas);

function drawTrail(x,y){
    const cx = canvas.width/2, cy = canvas.height/2, cr = Math.min(canvas.width, canvas.height)/2 - 10;
    if(typeof x!=='undefined' && typeof y!=='undefined'){ trail.push({x:x,y:y}); if(trail.length>cfg.trail) trail.shift(); }
    if(!trail.length || trail.length<2){ ctx.clearRect(0,0,canvas.width,canvas.height); return; }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const trailColor = (getComputedStyle(document.documentElement).getPropertyValue('--trail-color')).trim();
    const first = trail[0]; const entriesAreNormalized = Math.abs(first.x)<=1.01 && Math.abs(first.y)<=1.01;
    for(let i=1;i<trail.length;i++){
        const p0=trail[i-1],p1=trail[i],t=i/trail.length;
        const x0=entriesAreNormalized?cx+p0.x*cr:p0.x, y0=entriesAreNormalized?cy+p0.y*cr:p0.y;
        const x1=entriesAreNormalized?cx+p1.x*cr:p1.x, y1=entriesAreNormalized?cy+p1.y*cr:p1.y;
        if(!isFinite(x0)||!isFinite(y0)||!isFinite(x1)||!isFinite(y1)) continue;
        ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x1,y1);
        ctx.lineWidth = 10*(t*2); ctx.lineCap='round'; ctx.globalAlpha=1; ctx.strokeStyle=trailColor; ctx.stroke();
    }
    ctx.globalAlpha=1;
}

/* =============
   Color Palette
   ============= */

const colors = [
	"#FFE5E5","#FFB3B3","#FF8080","#FF4D4D","#E60000","#B30000","#800000","#4D0000",
	"#FFF0E5","#FFD1B3","#FFB380","#FF944D","#FF6600","#CC5200","#993D00","#662900",
	"#FFFDE5","#FFF7B3","#FFF080","#FFEA4D","#FFD700","#CCAC00","#998200","#665700",
	"#F5FFE5","#E0FFB3","#CCFF80","#B8FF4D","#99FF00","#77CC00","#559900","#336600",
	"#E5FFE5","#B3FFB3","#80FF80","#4DFF4D","#00E600","#00B300","#008000","#004D00",
	"#E5FFF9","#B3FFF0","#80FFE6","#4DFFDB","#00E6CC","#00B3A0","#008073","#004D47",
	"#E5F9FF","#B3EDFF","#80E0FF","#4DD3FF","#00BFFF","#0099CC","#007399","#004D66",
	"#E5EFFF","#B3CCFF","#8099FF","#4D66FF","#0033FF","#0029CC","#001F99","#001466",
	"#F0E5FF","#D1B3FF","#B380FF","#944DFF","#6600FF","#5200CC","#3D0099","#290066",
	"#FFE5F7","#FFB3E6","#FF80D6","#FF4DC5","#FF00AA","#CC0088","#990066","#660044",
	"#FFFFFF","#E6E6E6","#CCCCCC","#999999","#666666","#333333","#1A1A1A","#000000",
	"#00000000"
];

const colorPanel = document.getElementById('colorPanel');
// Create mode toggle
const modeToggle = document.createElement("div"); modeToggle.className = 'modeToggle';
const bgBtn = document.createElement("button"); bgBtn.textContent = "BACKGROUND"; bgBtn.style.font = "inherit"; bgBtn.style.padding="4px"; bgBtn.style.border="none"; bgBtn.style.cursor="pointer"; bgBtn.style.background="#888"; bgBtn.style.color="#fff";
const txtBtn = document.createElement("button"); txtBtn.textContent = "LABEL"; txtBtn.style.font = "inherit"; txtBtn.style.padding="4px"; txtBtn.style.border="none"; txtBtn.style.cursor="pointer"; txtBtn.style.background="#000"; txtBtn.style.color="#fff";
modeToggle.appendChild(bgBtn); modeToggle.appendChild(txtBtn);
colorPanel.appendChild(modeToggle);

let colorMode = "background";
bgBtn.addEventListener("click", () => { colorMode = "background"; bgBtn.style.background="#888"; txtBtn.style.background="#000"; });
txtBtn.addEventListener("click", () => { colorMode = "text"; txtBtn.style.background="#888"; bgBtn.style.background="#000"; });

colors.forEach(c => {
  const swatch = document.createElement("div");
  swatch.className = "swatch";
  swatch.style.backgroundColor = c;

  // Preview on hover
  swatch.addEventListener("mouseenter", () => {
    if (!colorPanel.targetBtn) return;
    const btn = colorPanel.targetBtn;
    const btnName = btn.dataset.btn;
    if (colorMode === "background") {
      btn.style.backgroundColor = c;
    } else {
      btn.style.color = c;
    }
  });

  // Revert preview when hover ends
  swatch.addEventListener("mouseleave", () => {
    if (!colorPanel.targetBtn) return;
    const btn = colorPanel.targetBtn;
    const btnName = btn.dataset.btn;
    if (colorMode === "background") {
      btn.style.backgroundColor = appState.buttons[btnName]?.backgroundColor || "";
    } else {
      btn.style.color = appState.buttons[btnName]?.color || "";
    }
  });

  // Apply on click
  swatch.addEventListener("click", () => {
    if (!colorPanel.targetBtn) return;
    const btnName = colorPanel.targetBtn.dataset.btn;
    if (colorMode === "background") {
      colorPanel.targetBtn.style.backgroundColor = c;
      updateColor(btnName, c, appState.buttons[btnName]?.color);
    } else {
      colorPanel.targetBtn.style.color = c;
      updateColor(btnName, appState.buttons[btnName]?.backgroundColor, c);
    }
  });

  colorPanel.appendChild(swatch);
});


// Open panel on right-click and also on left-click to select an awaiting target
Object.values(btnEls).forEach(btn => {
  btn.addEventListener("contextmenu", e => {
    e.preventDefault();
    colorPanel.style.display = "flex";
    colorPanel.targetBtn = btn;
  });
  btn.addEventListener("click", e => {
    if (colorPanel.style.display === "flex") {
        colorPanel.targetBtn = btn;
        e.stopPropagation();
    }
  });
});

document.addEventListener("mousedown", e => {
  if (!colorPanel.contains(e.target) && e.button === 0) {
    colorPanel.style.display = "none";
    colorPanel.targetBtn = null;
  }
});

/* ======================
   Click to set target + close palette
   ====================== */

// bring color panel to bottom anchored
colorPanel.style.position = "fixed";
colorPanel.style.bottom = "0px";
colorPanel.style.left = "0px";
colorPanel.style.width = "100%";
colorPanel.style.padding = "10px";
colorPanel.style.zIndex = "1000";
colorPanel.style.display = "none";

/* ======================
   ANIMATE LOOP
   ====================== */

function animate() {
    // Always detect active gamepad each frame
    activeGamepadIndex = detectActiveGamepad();
    const pad = navigator.getGamepads()[activeGamepadIndex] || null;

    updateButtons(pad);       // update button states
    handleDpadMovement(pad);  // move selected element with D-pad

    // Get stick coordinates
    const { x, y } = getStickXY(pad);
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const radius = canvas.width / 2 - 25;
    const jx = cx + x * radius;
    const jy = cy + y * radius;

    joystick.style.left = jx + 'px';
    joystick.style.top = jy + 'px';

    // Update marker
    const deg = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
    let idx = -1;
    if (Math.hypot(x, y) > 0.5) idx = Math.round(deg / 45) % 8;
    updateMarkers(idx);

    // Trail
    trail.push({ x: jx, y: jy });
    if (trail.length > cfg.trail) trail.shift();
    drawTrail();

    requestAnimationFrame(animate);
}
animate();

/* ======================
   Init & boot
   ====================== */

loadState(); // apply stored state

/* Attach initial saved styles back into state if not present (ensures appState contains everything) */
for (const key in btnEls) {
    if (!appState.buttons[key]) {
        const el = btnEls[key];
        const cs = window.getComputedStyle(el);
        appState.buttons[key] = {
            top: el.style.top || cs.top,
            left: el.style.left || cs.left,
            width: el.style.width || cs.width,
            height: el.style.height || cs.height,
            borderRadius: el.style.borderRadius || cs.borderRadius,
            fontSize: el.style.fontSize || cs.fontSize,
            display: el.style.display || cs.display,
            backgroundColor: el.style.backgroundColor || cs.backgroundColor,
            color: el.style.color || cs.color,
            label: (el.textContent||"").trim()
        };
    }
}
if (!appState.joystick || Object.keys(appState.joystick).length===0) {
    const cs = window.getComputedStyle(stickWrapper);
    appState.joystick = {
        top: stickWrapper.style.top || cs.top,
        left: stickWrapper.style.left || cs.left,
        width: stickWrapper.style.width || cs.width,
        height: stickWrapper.style.height || cs.height,
        borderRadius: stickWrapper.style.borderRadius || cs.borderRadius,
        display: stickWrapper.style.display || cs.display
    };
}
scheduleSave();

/* ================
   Profile hotkeys
   ================ */
document.addEventListener("keydown", e => {
    if (!e.ctrlKey && e.key.startsWith("F")) {
        const n = parseInt(e.key.slice(1));
        if (n >= 1 && n <= PROFILE_COUNT) loadProfile(n);
    }
    if (e.ctrlKey && e.key.startsWith("F")) {
        const n = parseInt(e.key.slice(1));
        if (n >= 1 && n <= PROFILE_COUNT) saveProfile(n);
    }
});

/* Expose some functions on window for convenience */
window.trailpad = {
    saveState: forceSave,
    scheduleSave,
    updatePosition,
    updateSize,
    updateLabel,
    updateColor,
    setHiddenButton,
    setJoystickHidden,
    saveProfile,
    loadProfile
};

// Reset
function resetJoystick() {
    // Recenter joystick head
    resizeCanvas(); // ensures canvas size is up-to-date
    joystick.style.left = (canvas.width / 2) + "px";
    joystick.style.top = (canvas.height / 2) + "px";

    // Reset marker positions
    updateMarkers(-1);

    // Reset base position
    const baseComputed = window.getComputedStyle(base);
    base.style.top = baseComputed.top;
    base.style.left = baseComputed.left;
    base.style.width = baseComputed.width;
    base.style.height = baseComputed.height;
    base.style.borderRadius = baseComputed.borderRadius;

    updatePosition("base", base.style.top, base.style.left);
    updateSize("base", base.style.width, base.style.height, base.style.borderRadius);

    // Make sure joystick & base are visible
    stickWrapper.style.display = "block";
    base.style.display = "block";

    appState.joystick.display = "block";
    appState.base.display = "block";
}

function resetLayout() { // Hard-coded defaults
    // Base
    appState.base = {
        top: "40px",
        left: "30px",
        width: "690px",
        height: "250px",
        borderRadius: "0px",
        display: "block",
        backgroundColor: "rgba(0,0,0,0.6)"
    };
    applyElementData(base, appState.base);

    // Stick wrapper
    appState.joystick = {
        top: "50px",
        left: "50px",
        width: "230px",
        height: "230px",
        borderRadius: "0px",
        display: "block"
    };
    applyElementData(stickWrapper, appState.joystick);

    // Buttons
    const defaults = {
        Up: { top: "390px", left: "120px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee" },
        Down: { top: "290px", left: "120px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee" },
        Left: { top: "290px", left: "20px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee" },
        Right: { top: "290px", left: "220px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee" },
        A: { top: "170px", left: "300px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "A" },
        B: { top: "170px", left: "400px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "B" },
        X: { top: "70px", left: "300px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "X" },
        Y: { top: "70px", left: "400px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "Y" },
        LB: { top: "70px", left: "600px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "LB" },
        RB: { top: "70px", left: "500px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "RB" },
        LT: { top: "170px", left: "600px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "LT" },
        RT: { top: "170px", left: "500px", width: "90px", height: "90px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "RT" },
        LS: { top: "260px", left: "360px", width: "70px", height: "70px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "LS" },
        RS: { top: "260px", left: "560px", width: "70px", height: "70px", borderRadius: "50%", fontSize: "40px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "RS" },
        View: { top: "20px", left: "300px", width: "90px", height: "40px", borderRadius: "30px", fontSize: "20px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "View" },
        Menu: { top: "20px", left: "400px", width: "90px", height: "40px", borderRadius: "30px", fontSize: "20px", display: "flex", backgroundColor: "rgba(48,48,48,1)", color: "#eee", label: "Menu" }
    };

    for (const key in defaults) {
        appState.buttons[key] = defaults[key];
        applyElementData(btnEls[key], defaults[key]);
    }

    // reset trail color
    appState.trailColor = "#CEEC73";
    document.documentElement.style.setProperty('--trail-color', appState.trailColor);

    resetJoystick();

    // clear hidden buttons
    appState.hiddenButtons = [];
    Object.values(btnEls).forEach(btn => btn.style.display = "flex");
	
	showToast("Layout Reset!");
}

// Add key listener to reset layout to default
document.addEventListener("keydown", e => {
    if(e.key === "F5") {
        e.preventDefault();
        resetLayout();
    }
});

// IMPORT/EXPORT TO-DO!

function saveLayout() {
    showToast("Layouts Saved");
}

function loadLayout() {
	showToast("Layout Loaded");
}

document.addEventListener("keydown", e => {
    if (e.ctrlKey && e.key === "s") {
        e.preventDefault();
        saveLayout();
    }
    if (e.ctrlKey && e.key === "o") {
        e.preventDefault();
        loadLayout();
    }
});

// One-time Update
const UPDATE_KEY = "trailpadUpdateShown_v1";

function showInitialUpdate(message) {
    const alreadySeen = localStorage.getItem(UPDATE_KEY);
    if (alreadySeen) return;

    toast.textContent = message; // keep \n in the string
    toast.style.whiteSpace = "pre-line"; // let \n show as line breaks
    toast.style.transform = "translateX(-50%) scale(1)";

    function hideOnClick() {
        toast.style.transform = "translateX(-50%) scale(0)";
        toast.removeEventListener("click", hideOnClick);
        localStorage.setItem(UPDATE_KEY, "true");
        window.open("https://twitter.com/chrisdejoya", "_blank");
    }

    toast.addEventListener("click", hideOnClick);
}

showInitialUpdate("Press Interact to customize\nPress F1 to F4 to switch profiles");

</script>
</body>
</html>
