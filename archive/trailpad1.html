<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Trailpad</title>
    
<style>
    @font-face {
        font-family: "Swiss721";
        src: url("fonts/Swiss721BT-Black.ttf") format("truetype"),
             url("fonts/Swiss721BT-Black.woff2") format("woff2"),
             url("fonts/Swiss721BT-Black.woff") format("woff");
        font-weight: bold;
        font-style: normal;
    }

    html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        background: transparent;
        font-family: "Swiss721", Arial, sans-serif;
        text-transform: uppercase;
        user-select: none;
	outline: 2px;
    }

    #app { position: absolute; top: 80px; left: 30px;}

    #stickWrapper {
        width: 230px; height: 230px;
        position: absolute; top: -10px; left: 10px;
        background: transparent;
        background-image: url("images/gate_strive.svg");
        background-size: cover;
        border-radius: 0%;
    }

    #stickCanvas {
        width: 100%; height: 100%;
        display: block;
        background: transparent;
        z-index: 1;
    }

    .joystickHead {
        position: absolute; left: 50%; top: 50%;
        width: 50px; height: 50px;
        border-radius: 50%;
        outline: 4px solid rgba(255,255,255,0.3);
        outline-offset: -4px;
        box-shadow: 0px 0px 0px 5px rgba(0,0,0,1);
        transform: translate(-50%,-50%) scale(1);
        pointer-events: none;
        display: flex; align-items: center; justify-content: center;
        font-weight: bold; font-size: 24px;
        transition: left 0.01s, top 0.01s, transform 0.1s;
        background: rgba(80,80,80,1); color: #000; z-index: 3;
    }

    #directionMarkers {
        position: absolute; top: 0; left: 0;
        width: 100%; height: 100%;
        pointer-events: none; z-index: 2;
    }

    .marker {
        position: absolute; width: 10px; height: 10px;
        border-radius: 50%; background: rgba(255,255,255,0.1);
        transform: translate(-50%, -50%);
        transition: all 0.1s;
    }

    .marker.active { background: rgba(255,255,255,1); }

    .btn {
        position: absolute; background: rgba(54,54,54,1);
        width: 90px; height: 90px;
        display: flex; align-items: center; justify-content: center;
        font-size: 40px; transition: 0.05s;
        border-radius: 50%; outline: 4px solid rgba(255,255,255,0.5);
        outline-offset: -4px; box-shadow: 0 2px 0px 6px rgba(0,0,0,1);
        filter: brightness(0.9);
        overflow: hidden; text-align: center; white-space: nowrap;
        color: #eee; cursor: pointer;
    }

    /*
    2XKO Default in-game button colors:
    L:		#B8ADD9
    M:		#9C7ACC
    H:		#6C30BF
    D:		#D98041
    S1:		#4CB6D9
    S2:		#CC5C5C
    T:		#C3E67E
    P:		#3D6DCC
    TH:		#D9B64C
    TA:		#805973
    DS:		#D9B64C
    ULT:	#7F47CC	
    */

    .btn[data-btn="Up"]		{ top: 230px; left: 80px; background-image: url("images/up.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Down"]	{ top: 390px; left: 80px; background-image: url("images/down.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Left"]	{ top: 310px; left: 0px; background-image: url("images/left.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }
    .btn[data-btn="Right"]	{ top: 310px; left: 160px; background-image: url("images/right.svg"); background-size: contain; background-repeat: no-repeat; background-position: center; }

    .btn[data-btn="A"] { top: 110px; left: 250px; }
    .btn[data-btn="B"] { top: 110px; left: 360px; }
    .btn[data-btn="X"] { top: 0px; left: 250px; }
    .btn[data-btn="Y"] { top: 0px; left: 360px; }

    .btn[data-btn="LB"] { top: 0px; left: 580px; }
    .btn[data-btn="RB"] { top: 0px; left: 470px; }
    .btn[data-btn="LT"] { top: 110px; left: 580px; }
    .btn[data-btn="RT"] { top: 110px; left: 470px; }

    .btn[data-btn="LS"] { top: 210px; left: 310px; width: 80px; height: 80px; }
    .btn[data-btn="RS"] { top: 210px; left: 530px; width: 80px; height: 80px; }
    .btn[data-btn="View"] { top: -60px; left: 310px; width: 80px; height: 40px; border-radius: 30px; font-size: 20px; }
    .btn[data-btn="Menu"] { top: -60px; left: 530px; width: 80px; height: 40px; border-radius: 30px; font-size: 20px; }

    .btn.active { filter: brightness(1.5); transform: scale(1.05); }
    .btn.selected { box-shadow: 0px 0px 0px 8px rgba(255,255,255,1) }
    .stickHighlight.selected { box-shadow: 0px 0px 0px 8px rgba(255,255,255,1) }

    :root {
    --trail-color: #CEEC73; /* default trail color */	
    }
	
	.color-panel {
	  position: fixed;
	  bottom: 10px;
	  right: 50%;
	  transform: translateX(100%);
	  display: none;
	  background: #222;
	  border: 4px solid #444;
	  padding: 8px 12px;
	  border-radius: 12px;
	  z-index: 9999;
	  flex-wrap: wrap;
	  gap: 6px;
	  max-width: 90%;
	  justify-content: center;
	}

	.color-swatch {
	  width: 30px;
	  height: 30px;
	  border-radius: 50%;
	  cursor: pointer;	  
	}
</style>
</head>
<body>
<div id="app">	
    <div id="stickWrapper" class="stickHighlight">
        <div id="directionMarkers">
            <div class="marker" id="marker0"></div>
            <div class="marker" id="marker1"></div>
            <div class="marker" id="marker2"></div>
            <div class="marker" id="marker3"></div>
            <div class="marker" id="marker4"></div>
            <div class="marker" id="marker5"></div>
            <div class="marker" id="marker6"></div>
            <div class="marker" id="marker7"></div>
        </div>
        <canvas id="stickCanvas"></canvas>
        <div class="joystickHead" id="joystickHead"></div>
    </div>

    <div class="btn" data-btn="Up"></div>
    <div class="btn" data-btn="Down"></div>
    <div class="btn" data-btn="Left"></div>
    <div class="btn" data-btn="Right"></div>
    <div class="btn" data-btn="A">A</div>
    <div class="btn" data-btn="B">B</div>
    <div class="btn" data-btn="X">X</div>
    <div class="btn" data-btn="Y">Y</div>
    <div class="btn" data-btn="LB">LB</div>
    <div class="btn" data-btn="RB">RB</div>
    <div class="btn" data-btn="LT">LT</div>
    <div class="btn" data-btn="RT">RT</div>
    <div class="btn" data-btn="LS">LS</div>
    <div class="btn" data-btn="RS">RS</div>
    <div class="btn" data-btn="View">View</div>
    <div class="btn" data-btn="Menu">Menu</div>
</div>

<script>
const cfg = {
    deadzone: 0.1,
    trail: 12,
    invertY: false,
    map: {
        A:0,
        B:1,
        X:2,
        Y:3,
        LB:4,
        RB:5,
        LT:6,
        RT:7,
        View:8,
        Menu:9,
        LS:10,
        RS:11,
        Up:12,
        Down:13,
        Left:14,
        Right:15
    },
    ignoredForJoystick: ['View','Menu','LS','RS','Up','Down','Left','Right']
};

const btnEls = {};
document.querySelectorAll('.btn').forEach(el => btnEls[el.dataset.btn] = el);

const savedLabels = JSON.parse(localStorage.getItem("buttonLabels") || "{}");
for (const key in savedLabels) if (btnEls[key]) btnEls[key].textContent = savedLabels[key];

const savedPositions = JSON.parse(localStorage.getItem("buttonPositions") || "{}");
for (const key in savedPositions) if (btnEls[key]) {
    btnEls[key].style.top = savedPositions[key].top;
    btnEls[key].style.left = savedPositions[key].left;
}

const savedSizes = JSON.parse(localStorage.getItem("elementSizes") || "{}");
const stickWrapper = document.getElementById('stickWrapper');
const joystick = document.querySelector('.joystickHead');
const movableElements = {...btnEls, stickWrapper};

const hiddenButtons = JSON.parse(localStorage.getItem("hiddenButtons") || "[]");
hiddenButtons.forEach(btnName => {
    if (btnEls[btnName]) {
        btnEls[btnName].style.display = "none";
        if (!cfg.ignoredForJoystick.includes(btnName)) cfg.ignoredForJoystick.push(btnName);
    }
});

const joystickHidden = localStorage.getItem("joystickHidden") === "true";
if (joystickHidden) {
    stickWrapper.style.display = "none";
}

for (const key in savedSizes) {
    const el = movableElements[key];
    if (el) {
        el.style.width = savedSizes[key].width || el.style.width;
        el.style.height = savedSizes[key].height || el.style.height;
        el.style.borderRadius = savedSizes[key].borderRadius || el.style.borderRadius;
        if (savedSizes[key].fontSize) el.style.fontSize = savedSizes[key].fontSize;
    }
}

const savedStickPos = JSON.parse(localStorage.getItem("stickWrapperPosition") || "{}");
if (savedStickPos.top) stickWrapper.style.top = savedStickPos.top;
if (savedStickPos.left) stickWrapper.style.left = savedStickPos.left;

// Editable labels
Object.values(btnEls).forEach(btn => {
    if (['Up','Down','Left','Right'].includes(btn.dataset.btn)) return;
    btn.addEventListener("dblclick", () => {
        if (btn.querySelector("input")) return;
        const oldText = btn.textContent.trim();
        btn.textContent = "";
        const input = document.createElement("input");
        input.value = oldText;
        input.style.width = "100%";
        input.style.height = "100%";
        input.style.fontSize = btn.style.fontSize || "36px";
        input.style.fontFamily = "inherit";
        input.style.textAlign = "center";
        input.style.textTransform = "uppercase";
        input.style.border = "none";
        input.style.outline = "none";
        input.style.background = "transparent";
        input.style.color = "inherit";
        input.style.padding = "0"; input.style.margin = "0";
        btn.appendChild(input);
        input.focus(); input.select();
        input.addEventListener("blur", save);
        input.addEventListener("keydown", e => {
            if (e.key === "Enter") save();
            else if (e.key === "Escape") btn.textContent = oldText;
        });
        function save() {
            const newText = input.value.trim();
            btn.textContent = newText;
            savedLabels[btn.dataset.btn] = newText;
            localStorage.setItem("buttonLabels", JSON.stringify(savedLabels));
        }
    });
});

// Select & move elements
let selectedElement = null;
Object.values(movableElements).forEach(el => {
    el.addEventListener('mousedown', e => {
        if (selectedElement && selectedElement !== el) selectedElement.classList?.remove("selected");
        selectedElement = el;
        el.classList.add("selected");
        e.stopPropagation();
    });
});
document.addEventListener("mousedown", () => {
    if (selectedElement) selectedElement.classList?.remove("selected");
    selectedElement = null;
});

// Keyboard Controls
document.addEventListener("keydown", e => {
    // ESC: reset everything
    if (e.key === "Escape") {
        localStorage.removeItem("buttonLabels");
        localStorage.removeItem("buttonPositions");
        localStorage.removeItem("stickWrapperPosition");
        localStorage.removeItem("elementSizes");
        localStorage.removeItem("hiddenButtons");
		localStorage.removeItem("buttonColors");
        location.reload();
        return;
    }

    // Unhide all
    if (e.key === "Home") {
        Object.values(btnEls).forEach(btn => btn.style.display = "flex");
        hiddenButtons.length = 0;
        localStorage.setItem("hiddenButtons", JSON.stringify(hiddenButtons));

        // Restore joystick too
        stickWrapper.style.display = "block";
        localStorage.removeItem("joystickHidden");

        // Always keep View and Menu ignored
        cfg.ignoredForJoystick = ['View', 'Menu', ...cfg.ignoredForJoystick.filter(b => b !== 'View' && b !== 'Menu')];
        e.preventDefault();
        return;
    }
    
    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top)||0, left = parseInt(style.left)||0;
    let width = parseInt(style.width)||0, height = parseInt(style.height)||0;
    let borderRadius = parseInt(style.borderRadius)||0;
    let fontSize = parseInt(style.fontSize)||36;
    let updated = false;

    function snap10(val){ return Math.round(val/10)*10; }

    if (e.ctrlKey) {
        if (e.key === "[") { fontSize = Math.max(8, fontSize-2); updated=true; e.preventDefault(); }
        if (e.key === "]") { fontSize += 2; updated=true; e.preventDefault(); }
        selectedElement.style.fontSize = fontSize + "px";
    } else {
        // Move
        if (!e.shiftKey) {
            if (e.key === "ArrowUp") { top -= 10; updated=true; }
            if (e.key === "ArrowDown") { top += 10; updated=true; }
            if (e.key === "ArrowLeft") { left -= 10; updated=true; }
            if (e.key === "ArrowRight") { left += 10; updated=true; }
        }

        // Resize
        if (e.shiftKey) {
            if (selectedElement.id === "stickWrapper") {
                if (e.key === "ArrowUp" || e.key === "ArrowRight") { 
                    width += 10; height += 10; updated = true; 
                }
                if (e.key === "ArrowDown" || e.key === "ArrowLeft") { 
                    width = Math.max(50, width - 10); 
                    height = Math.max(50, height - 10); 
                    updated = true; 
                }
            } else {
                if (e.key === "ArrowDown") { height -= 10; updated=true; }
                if (e.key === "ArrowUp") { height += 10; updated=true; }
                if (e.key === "ArrowLeft") { width -= 10; updated=true; }
                if (e.key === "ArrowRight") { width += 10; updated=true; }
            }
        }

        if (e.key === "[") { borderRadius = Math.max(0,borderRadius-10); updated=true; }
        if (e.key === "]") { borderRadius += 10; updated=true; }
    
	// Hide
	if (e.key === "Delete") {
	    if (selectedElement?.classList.contains("btn")) {
	        // Existing button hide logic
	        selectedElement.style.display = "none";
	        const btnName = selectedElement.dataset.btn;
	        if (!hiddenButtons.includes(btnName)) hiddenButtons.push(btnName);
	        localStorage.setItem("hiddenButtons", JSON.stringify(hiddenButtons));
	        if (!cfg.ignoredForJoystick.includes(btnName)) cfg.ignoredForJoystick.push(btnName);
	        e.preventDefault();
	        return;
	    } else if (selectedElement?.id === "stickWrapper") {
	        // Hide the entire joystick and its parts
	        selectedElement.style.display = "none";
	        localStorage.setItem("joystickHidden", "true");
	        e.preventDefault();
	        return;
	    }
	}
    }

    if (updated) {
        selectedElement.style.top = snap10(top)+"px";
        selectedElement.style.left = snap10(left)+"px";
        selectedElement.style.width = snap10(width)+"px";
        selectedElement.style.height = snap10(height)+"px";
        selectedElement.style.borderRadius = snap10(borderRadius)+"px";
        selectedElement.style.fontSize = fontSize + "px";

        const savedSizesLS = JSON.parse(localStorage.getItem("elementSizes")||"{}");
        if (selectedElement.dataset?.btn) {
            savedPositions[selectedElement.dataset.btn] = {top:selectedElement.style.top, left:selectedElement.style.left};
            localStorage.setItem("buttonPositions", JSON.stringify(savedPositions));
            savedSizesLS[selectedElement.dataset.btn] = {
                width:selectedElement.style.width,
                height:selectedElement.style.height,
                borderRadius:selectedElement.style.borderRadius,
                fontSize:selectedElement.style.fontSize
            };
        } else if (selectedElement.id==="stickWrapper") {
            localStorage.setItem("stickWrapperPosition", JSON.stringify({top:selectedElement.style.top,left:selectedElement.style.left}));
            savedSizesLS["stickWrapper"] = {
                width:selectedElement.style.width,
                height:selectedElement.style.height,
                borderRadius:selectedElement.style.borderRadius
            };

            // recalc canvas + recenter joystick & markers
            resizeCanvas();
            joystick.style.left = (canvas.width / 2) + "px";
            joystick.style.top = (canvas.height / 2) + "px";
            updateMarkers(-1);
        }
        localStorage.setItem("elementSizes", JSON.stringify(savedSizesLS));
    }
});

function moveSelectedElement(dx, dy) {
    if (!selectedElement) return;

    const style = window.getComputedStyle(selectedElement);
    let top = parseInt(style.top) || 0;
    let left = parseInt(style.left) || 0;

    top += dy;
    left += dx;

    // Snap to 10px grid
    function snap10(val) { return Math.round(val / 10) * 10; }
    selectedElement.style.top = snap10(top) + "px";
    selectedElement.style.left = snap10(left) + "px";

    // Save position
    const savedPositionsLS = JSON.parse(localStorage.getItem("buttonPositions") || "{}");
    if (selectedElement.dataset?.btn) {
        savedPositionsLS[selectedElement.dataset.btn] = { top: selectedElement.style.top, left: selectedElement.style.left };
        localStorage.setItem("buttonPositions", JSON.stringify(savedPositionsLS));
    } else if (selectedElement.id === "stickWrapper") {
        localStorage.setItem("stickWrapperPosition", JSON.stringify({ top: selectedElement.style.top, left: selectedElement.style.left }));
    }
}

const elementMoveTimers = { up: 0, down: 0, left: 0, right: 0 };
const moveDelay = 150; // ms between movements
const moveStep = 10;   // 10px increments

function handleDpadMovement(pad) {
    if (!selectedElement || !pad) return;

    const now = performance.now();

    const directions = [
        { btn: 12, dx: 0, dy: -moveStep, key: "up" },   // Up
        { btn: 13, dx: 0, dy: moveStep, key: "down" },  // Down
        { btn: 14, dx: -moveStep, dy: 0, key: "left" }, // Left
        { btn: 15, dx: moveStep, dy: 0, key: "right" }  // Right
    ];

    directions.forEach(dir => {
        if (pad.buttons[dir.btn]?.pressed && now - elementMoveTimers[dir.key] > moveDelay) {
            moveSelectedElement(dir.dx, dir.dy);
            elementMoveTimers[dir.key] = now;
        }
    });
}

// Gamepad logic
let activeGamepadIndex = null;

function detectActiveGamepad() {
    const gamepads = navigator.getGamepads();
    for (let i = 0; i < gamepads.length; i++) {
        const pad = gamepads[i];
        if (!pad) continue;
        const anyButtonPressed = pad.buttons.some(b => b.pressed);
        const anyAxisMoved = pad.axes.some(a => Math.abs(a) > cfg.deadzone);
        if (anyButtonPressed || anyAxisMoved) return i;
    }
    return null;
}

window.addEventListener('gamepadconnected', e => console.log("Connected:", e.gamepad.id, e.gamepad.index));
window.addEventListener('gamepaddisconnected', e => {
    console.log("Disconnected:", e.gamepad.id, e.gamepad.index);
    if (activeGamepadIndex === e.gamepad.index) activeGamepadIndex = null;
});

const lastPressedTimes = {};
function updateButtons(pad){
    if(!pad?.buttons){
        joystick.style.transform='translate(-50%,-50%) scale(1)'; joystick.textContent='';
        joystick.style.background='rgba(64,64,64,1)'; joystick.style.color='#fff';
        Object.values(btnEls).forEach(btn=>btn.classList.remove('active'));
        return;
    }
    for(const key in btnEls){
        const idx=cfg.map[key];
        if(idx===undefined) continue;
        const pressed=!!pad.buttons[idx]?.pressed;
        btnEls[key].classList.toggle('active',pressed);
        lastPressedTimes[key]=pressed?performance.now():lastPressedTimes[key]||0;
    }
    let activeBtn=null,latestTime=-1;
    for(const key in lastPressedTimes){
        if(btnEls[key].classList.contains('active')&&!cfg.ignoredForJoystick.includes(key)
           && lastPressedTimes[key]>latestTime){
            latestTime=lastPressedTimes[key]; activeBtn=key;
        }
    }
    if(activeBtn){
        const btnColor=window.getComputedStyle(btnEls[activeBtn]).backgroundColor;
        const btnTextColor=window.getComputedStyle(btnE